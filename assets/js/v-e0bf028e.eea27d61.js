(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6809],{3567:(s,a,e)=>{"use strict";e.r(a),e.d(a,{data:()=>n});const n={key:"v-e0bf028e",path:"/os/centos/centos-uses-scheduled-tasks-to-perform-tasks-every-seconds.html",title:"Linux下使用定时任务每隔N秒钟执行任务",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"使用脚本死循环的方式",slug:"使用脚本死循环的方式",children:[{level:3,title:"脚本内容",slug:"脚本内容",children:[]},{level:3,title:"定时任务",slug:"定时任务",children:[]}]}],filePathRelative:"os/centos/centos-uses-scheduled-tasks-to-perform-tasks-every-seconds.md",git:{updatedTime:1629081394e3,contributors:[]}}},6102:(s,a,e)=>{"use strict";e.r(a),e.d(a,{default:()=>r});const n=(0,e(6252).uE)('<h1 id="linux下使用定时任务每隔n秒钟执行任务" tabindex="-1"><a class="header-anchor" href="#linux下使用定时任务每隔n秒钟执行任务" aria-hidden="true">#</a> Linux下使用定时任务每隔N秒钟执行任务</h1><p>前一段时间做了一个项目对定是请求实时性要求比较高，需要精确到秒级发送HTTP请求。总结一下使用Linux的<code>crontab</code>实现的一种方式。</p><h2 id="使用脚本死循环的方式" tabindex="-1"><a class="header-anchor" href="#使用脚本死循环的方式" aria-hidden="true">#</a> 使用脚本死循环的方式</h2><p>可能需要考虑什么时候开始执行脚本和更加方便的结束脚本执行，具体涉及到的文件有：</p><ul><li><p><code>/path/start_refresh_data.sh</code> 开始执行的脚本</p></li><li><p><code>/path/stop_data_refresh.sh</code> 停止执行的脚本</p></li></ul><h3 id="脚本内容" tabindex="-1"><a class="header-anchor" href="#脚本内容" aria-hidden="true">#</a> 脚本内容</h3><h4 id="启动脚本start-refresh-data-sh" tabindex="-1"><a class="header-anchor" href="#启动脚本start-refresh-data-sh" aria-hidden="true">#</a> 启动脚本<code>start_refresh_data.sh</code></h4><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>\n\n<span class="token comment"># php脚本路径</span>\n<span class="token assign-left variable">php_bin</span><span class="token operator">=</span><span class="token string">&quot;/usr/bin/php&quot;</span>\n\n<span class="token comment"># artisan路径</span>\n<span class="token assign-left variable">artisan_file</span><span class="token operator">=</span><span class="token string">&quot;/path/laravel/&quot;</span>\n\n<span class="token keyword">while</span> <span class="token boolean">true</span>\n<span class="token keyword">do</span>\n    <span class="token variable">${php_bin}</span> <span class="token variable">${artisan_file}</span> <span class="token keyword">in</span>\n    <span class="token function">sleep</span> <span class="token number">1</span>\n<span class="token keyword">done</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>脚本很简单，只是死循环的执行一个<code>laravel</code>框架的一个artisan命令。</p></blockquote><h4 id="暂停脚本-path-stop-data-refresh-sh" tabindex="-1"><a class="header-anchor" href="#暂停脚本-path-stop-data-refresh-sh" aria-hidden="true">#</a> 暂停脚本<code>/path/stop_data_refresh.sh</code></h4><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>\n\n/bin/pkill -f start_refresh_data.sh\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>通过匹配脚本名称杀死进程。</p></blockquote><h3 id="定时任务" tabindex="-1"><a class="header-anchor" href="#定时任务" aria-hidden="true">#</a> 定时任务</h3><p>通过执行命令<code>crontab -e</code>，写入到文件中。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token number">0</span> <span class="token number">12</span> * * * <span class="token function">nohup</span> /bin/bash /path/start_data_refresh.sh <span class="token operator">&amp;</span>\n00 00 * * * /bin/bash /path/stop_data_refresh.sh\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>上面的定时任务是每天中午12点开始执行任务，晚上12点结束。</p></blockquote><p>值得注意的是，执行<code>start_data_refresh.sh</code>脚本的时候，<strong>不能设定为每分钟执行</strong>，可以选择某个时间点执行。</p><p>这样在执行<code>stop_data_refresh.sh</code>脚本的时候才不至于出现在当前这一分钟内不执行，到了下一分钟又开始执行<code>start_data_refresh.sh</code>脚本的情况。</p><p>如果您有更好的解决方案，欢迎分享。</p>',19),r={render:function(s,a){return n}}}}]);